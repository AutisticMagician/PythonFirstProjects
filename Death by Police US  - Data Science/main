#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Mon Jul 25 10:07:49 2022

@author: theautisticmagician
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px

df_hh_income = pd.read_csv('Median_Household_Income_2015.csv', encoding="windows-1252")
df_rel_poverty = pd.read_csv('Pct_People_Below_Poverty_Level.csv', encoding="windows-1252")
df_rel_completed_hs = pd.read_csv('Pct_Over_25_Completed_High_School.csv', encoding="windows-1252")
df_rel_race_city = pd.read_csv('Share_of_Race_By_City.csv', encoding="windows-1252")
df_fatalities = pd.read_csv('Deaths_by_Police_US.csv', encoding="windows-1252")

#general information
list_dfs = [df_hh_income,df_rel_poverty,df_rel_completed_hs, df_rel_race_city,df_fatalities ]
shapes = [df.shape for df in list_dfs]
#sum for each column (Series with columns as index) then sum columns/index of Series
nans_df = [df.isna().sum().sum() for df in list_dfs]
dups_df = [df.duplicated().sum().sum() for df in list_dfs]

#nans exist, check nums
nans_series = [df.isna().sum() for df in list_dfs]
nans_columns = [series.where(series!=0).dropna().index.tolist() for series in nans_series]

#df_hh_income["Median Income"] exploration of values
income_exploration = { "(X)" : df_hh_income["Median Income"].where(df_hh_income["Median Income"] == "(X)").count(),
                      "-" : df_hh_income["Median Income"].where(df_hh_income["Median Income"] == "-").count()
                      
                      }
#as - is used for none, nan will be cleaned from df_hh_income, nan in fatalities in respective columns hard to interprete, why was data not taken?
#armed and flee should always be available, will be dropped, but should be inspected as armed can be evaluated post fatality and neither require ID


#purging dfs
for df in list_dfs:
    df.dropna(inplace=True)
    
#prepare rel_poverty for barplot
rel_poverty = df_rel_poverty.drop("City", axis = 1)
rel_poverty["poverty_rate"] = pd.to_numeric(rel_poverty["poverty_rate"], errors = "coerce")
rel_poverty.dropna(inplace = True)
rel_poverty = rel_poverty.groupby("Geographic Area").mean().sort_values("poverty_rate",ascending=False)
  
#graph rel_poverty
plt.figure(figsize=(57,8))      
pov_chart = sns.barplot(x= rel_poverty.index,y=rel_poverty["poverty_rate"])        
plt.ylabel("Poverty Rate")
ax=plt.gca()
miny= rel_poverty["poverty_rate"].min()
maxy = rel_poverty["poverty_rate"].max()
ax.set_ylim([miny,maxy])
pov_chart.figure.savefig("Poverty rate by state")

#prepare rel_completed_hs
rel_hs = df_rel_completed_hs.drop("City", axis = 1)
rel_hs["percent_completed_hs"] = pd.to_numeric(rel_hs["percent_completed_hs"], errors = "coerce")
rel_hs.dropna(inplace = True)
rel_hs = rel_hs.groupby("Geographic Area").mean().sort_values("percent_completed_hs",ascending=False)        

plt.figure(figsize=(57,8))      
hs_chart = sns.barplot(x= rel_hs.index,y=rel_hs["percent_completed_hs"])        
plt.ylabel("HS Graduation rate")
ax=plt.gca()
miny= rel_hs["percent_completed_hs"].min()
maxy = rel_hs["percent_completed_hs"].max()
ax.set_ylim([miny,maxy])
hs_chart.figure.savefig("HS graduation by state")

#merge poverty and hs
pov_hs_merged = rel_poverty.merge(rel_hs, left_index=True, right_index=True)


#KDE plot
merged_chart =sns.jointplot( x =pov_hs_merged["poverty_rate"],y=pov_hs_merged["percent_completed_hs"] ,kind="kde" )
merged_chart.set_axis_labels('Poverty Rate','HS Graduation Rate')
merged_chart.fig.savefig("kde poverty and hs graduation")

#LinReg
linreg_merged =sns.jointplot(x =pov_hs_merged["poverty_rate"],y=pov_hs_merged["percent_completed_hs"], kind="reg")
linreg_merged.set_axis_labels('Poverty Rate','HS Graduation Rate')
linreg_merged.fig.savefig("linreg poverty and hs graduation")

#prepare ethnical distributen per state
ethnic_distribution = df_rel_race_city.drop("City", axis = 1)
ethnic_distribution.iloc[:,1:] = ethnic_distribution.iloc[:,1:].apply(pd.to_numeric, errors = "coerce")
ethnic_distribution = ethnic_distribution.groupby("Geographic area").mean()
#reduce share as multi-ethnicity is counted as a full ethnicity per share, multiply each row by the missing factor to reach 100
ethnic_distribution = ethnic_distribution.mul(100/ethnic_distribution.sum(axis=1),axis=0)

#create a distribution chart
ethnic_distribution_chart = px.bar(ethnic_distribution,x=ethnic_distribution.index, y=ethnic_distribution.columns)
ethnic_distribution_chart.write_html("ethnic distribution.html")

#prepare data for fat by race and fat_bygender
fat_byrace = df_fatalities.value_counts("race")
fat_bygender = df_fatalities.value_counts("gender")
#pie chart for fatalities by race and gender
fat_byrace_chart = px.pie(fat_byrace,values=fat_byrace, names=fat_byrace.index, title ="Fatality share by ethnicity")
fat_byrace_chart.write_html("fat by race.html")

fat_bygender_chart= px.pie(fat_bygender,values=fat_bygender, names=fat_bygender.index, title ="Fatality share by gender")
fat_bygender_chart.write_html("fat by gender.html")
#find USA-wide ethnicity share
global_eth_share = ethnic_distribution.mean()
global_eth_share_chart = px.pie(global_eth_share, values=global_eth_share,names = global_eth_share.index,title="USA wide ethn share per data")
global_eth_share_chart.write_html("global eth share.html")

#merging ethnicity and fat by eth to set them in relation
fat_byrace.index = ["share_white","share_black", "share_hispanic", "share_asian", "share_native_american", "Other"] 
byrace_merged = pd.merge(fat_byrace.rename("Fatality by race"),global_eth_share.rename("Share of ethnicity"),left_index=True,right_index=True)  
byrace_merged["Share Fatalities"] = byrace_merged["Fatality by race"]/byrace_merged["Fatality by race"].sum()
#P(E|F) is missing P(F) as currently no absolute value of population, therefore no further integration/testing


#Police killing and State
fat_bystate = df_fatalities["state"].value_counts()

poverty_and_fats = rel_poverty.merge(fat_bystate.rename("fatalities"), left_index=True, right_index=True)

poverty_and_fats_chart = sns.jointplot(x=poverty_and_fats["poverty_rate"],y=poverty_and_fats["fatalities"], kind="kde")
poverty_and_fats_chart.set_axis_labels("Poverty rate","Nr. Fatalities" )
poverty_and_fats_chart.fig.savefig("KDE Poverty Rate and Fats")

#Killings over time is an idea, but requires abs pop values, as the killing rate might stay the same even with increasing kill numbers if population growth >0




























